/*
 * Qwizzler
 * QuizActivity.java
 * Created by Andrew Epstein
 * Copyright (c) 2018. All rights reserved.
 * Last modified : 2/15/18 5:08 PM
 */

package cloud.workingtitle.qwizzler;

import android.content.Context;
import android.os.Bundle;
import android.support.annotation.NonNull;
import android.support.v4.view.GestureDetectorCompat;
import android.support.v7.app.AppCompatActivity;
import android.util.Log;
import android.view.GestureDetector;
import android.view.Gravity;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.CompoundButton;
import android.widget.EditText;
import android.widget.LinearLayout;
import android.widget.ScrollView;
import android.widget.TextView;
import android.widget.Toast;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Locale;

public class QuizActivity extends AppCompatActivity {

  // index of the question currently being displayed
  private int mCurrentQuestion = 0;

  // library of questions to ask
  //private ArrayList<Question> quiz = new ArrayList<>();

  // provides swipe support for forward / backward in the question list
  private GestureDetectorCompat mDetector;

  // used for converting pixels to density independent pixels (dp)
  private double scale;

  // VISUAL CONTROLS
  // mScrollView is the main "stage" where all question choices will appear
  private ScrollView mScrollView;
  // mQuestionText is the TextView where the Question itself will appear
  private TextView mQuestionText;

  // navigation / operation buttons
  private Button hint_button;
  private Button check_answer_button;
  private Button previous_button;
  private Button next_button;
  private Button get_score_button;


  /**
   * This method is called during the app lifecycle (e.g. screen rotations)
   * it adds the currentQuestion and quiz globals to the bundle.
   * The parcelable array comes from the Parcelable interface of the Question class
   *
   * @param savedInstanceState bundle that is generated by Android
   *
   */
  @Override
  public void onSaveInstanceState(Bundle savedInstanceState) {
    savedInstanceState.putInt("CurrentQuestion", mCurrentQuestion);
    savedInstanceState.putParcelableArrayList("quiz", Quiz.getAll());
    super.onSaveInstanceState(savedInstanceState);
  }


  /**
   * Method to deal with final destruction / back button press. It's a terrible workaround
   * for a problem I don't thoroughly understand.
   */
  @Override
  public void onDestroy() {
    if (isFinishing())
      Quiz.destroy(); // if you can't free the data, at least clear it
    super.onDestroy();
    Log.e("DESTROY", "onDestroy called");
  }

  /**
   * This is the Activity's entry point. It's called at startup and during the app lifecycle.
   * Initialization methods are called from here, including wiring the visual elements to listeners
   *
   * @param savedInstanceState bundle that is generated by Android
   */
  @Override
  protected void onCreate(Bundle savedInstanceState) {
    Log.e("CREATE", "onCreate called: " + String.valueOf(savedInstanceState));
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_quiz);

    // initialize the mDectector global to an instance of itself
    mDetector = new GestureDetectorCompat(this, new CustomGestureListener());

    // create global references to static on-screen elements (buttons, display box, etc.)
    loadControls();

    // if there is data in savedInstanceState, unbundle it and apply it to the appropriate globals
    if (savedInstanceState != null) {
      mCurrentQuestion = savedInstanceState.getInt("CurrentQuestion", 0);
      ArrayList<Question> temp = savedInstanceState.getParcelableArrayList("quiz");
      Quiz.setAll(temp);
    }
    else createQuestions(); // otherwise, create a new batch of questions from code*/
    
    // units in dynamic app are in pixels. This changes the scale depending on the device.
    scale = getResources().getDisplayMetrics().density;

    // initiate the creation cycle of any screen elements
    updateDisplay();

    // wire the Previous button onCLick event to a method
    previous_button.setOnClickListener(new View.OnClickListener() {
      @Override
      public void onClick(View v) {
        // get the previous Question from the storehouse
        mCurrentQuestion = previousQuestion();
        // display it
        updateDisplay();
      }
    });

    // wire the Next button onClick event to a method
    next_button.setOnClickListener(new View.OnClickListener() {
      @Override
      public void onClick(View v) {
        // get the next question from the quiz storehouse
        mCurrentQuestion = nextQuestion();
        // display it
        updateDisplay();
      }
    });

    // wire the Check Answer button onClick event to a method
    check_answer_button.setOnClickListener(new View.OnClickListener() {
      @Override
      public void onClick(View v) {
        // initiate the check answer method
        checkAnswer();
        // update the display after the answer has been evaluated
        updateDisplay();
      }
    });

    get_score_button.setOnClickListener(new View.OnClickListener() {
      @Override
      public void onClick(View v) {
        getScore();
      }
    });
  }


  /**
   * Compute a score based on the number of attempted questions
   * Send the result off to showToast() for display on screen
   */
  private void getScore() {
    // number of attempted questions
    int attempted = 0;
    // number of questions answered correctly
    double correct = 0.0;

    for (Question question : Quiz.getAll()) {
      if (question.isAnswered()) {
        ++attempted;
        if (question.getAnsweredCorrectly()) {
          ++correct;
        }
      }
    }
    if (attempted != 0) {
      showToast("You attempted " + attempted + " questions and got " + (int) correct + " correct!  That's " +
          String.valueOf(Math.round(100 * (correct / attempted))) + "%");
    }
    else {
      showToast("You haven't answered any questions!");
    }
  }

  /**
   * Checks the currently displayed question and determines if the user selections were correct
   */
  private void checkAnswer() {
    // current question - convenience variable
    Question question = Quiz.get(mCurrentQuestion);

    // checked quantity tracks how many checkboxes were ticked. It's used to determine if at least
    // one checkbox was selected.
    int checkedQuantity = 0;

    // all the choices for the current question - convenience variable
    ArrayList<Question.Choice> choices = Quiz.get(mCurrentQuestion).getChoices();

    // get a reference to the Linear Layout or Radio Group in the Scroll View
    ViewGroup parent = (ViewGroup) mScrollView.getChildAt(0);

    // loop through all the View elements in the parent ViewGroup
    for (int i = 0; i < parent.getChildCount(); i++) {
      TextView control = (TextView) parent.getChildAt(i);
      // is this a short answer type?
      if (control instanceof EditText) {
        // this is a text box - get the text and compare
        String providedAnswer = control.getText().toString();
        if (providedAnswer.isEmpty()) {
          showToast("You did not provide an answer");
          return;
        }
        // convenience variable holds the "correct" answer supplied in the constructor
        String correctAnswer = choices.get(i).getText();

        // shorthand to mark the question correct or incorrect
        ((ShortAnswer)question).setAnsweredCorrectly(correctAnswer.equalsIgnoreCase(providedAnswer), providedAnswer);
        if (question.getAnsweredCorrectly()) {
          showToast("Yay!");
        }
        else
        {
          showToast("Nope");
        }
        // all controls are disabled after the question has been answered
        // this is handled in the displayQuestion method, not needed here
        // control.setEnabled(false);
        return;
      }
      // if the code reaches this point, we're grading a multiple choice question
      if (((CompoundButton) control).isChecked()) { // the control was checked...
        ++checkedQuantity;
        choices.get(i).choose(); // save this choice for later
        if (!choices.get(i).isCorrect()) { // ... but it was a wrong choice
          question.setAnsweredCorrectly(false); // mark the question wrong
        }
      } else if (!((CompoundButton) control).isChecked() && checkedQuantity > 0) { // the control is not checked...
        if (choices.get(i).isCorrect()) { // ... but it should have been checked
          question.setAnsweredCorrectly(false); // mark question wrong
        }
      }
    }
    // all controls have been evaluated, provide feedback
    if (checkedQuantity == 0) { // question was not answered at all
      showToast("Please select an answer");
    }
    // the question was answered correctly
    else if (!question.isAnswered()) {
      question.setAnsweredCorrectly(true); // mark the question correct
      showToast("Yay!");
    }
    // the question was answered incorrectly
    else showToast("Nope");
  }


  /**
   * convenience helper for building / displaying Toast message
   * @param message the text of the message to display
   */
  private void showToast(String message) {
    Toast toast = Toast.makeText(this, message, Toast.LENGTH_SHORT);
    toast.setGravity(Gravity.CENTER, 0, 0);
    toast.show();
  }

  /**
   * gets references to on-screen controls so they can be referenced globally
   */
  private void loadControls() {
    mScrollView = findViewById(R.id.scroll_view_area);
    mQuestionText = findViewById(R.id.question);
    hint_button = findViewById(R.id.hint_button);
    check_answer_button = findViewById(R.id.check_answer_button);
    previous_button = findViewById(R.id.previous_button);
    next_button = findViewById(R.id.next_button);
    get_score_button = findViewById(R.id.get_score_button);
  }

  /**
   * Changes the button states depending on the question / quiz state
   */
  private void updateControls() {
    previous_button.setEnabled(mCurrentQuestion != 0);
    next_button.setEnabled(mCurrentQuestion < Quiz.size() - 1);
    if (Quiz.size() > 0) {
      boolean isAnswered = Quiz.get(mCurrentQuestion).isAnswered();
      check_answer_button.setEnabled(!isAnswered);
      hint_button.setEnabled(!isAnswered);
    }
  }

  /**
   * sets title bar display elements and initiates the question events sequence
   * this is the main daddy that's called every time there is a change
   */
  private void updateDisplay() {
    String appName = getString(R.string.app_name);
    Question question = null;
    if (Quiz.size() > 0) {
      question = Quiz.get(mCurrentQuestion);
      setTitle(String.format(Locale.US, appName + " -- Question %d of %d", mCurrentQuestion + 1, Quiz.size()));
    }
    // send the question to the Exception catcher
    askQuestions(question);

    // update the button controls to reflect any changed status
    updateControls();
  }

  // this is a fail-safe method to cope with swiping
  private int previousQuestion() {
    return mCurrentQuestion > 0 ? --mCurrentQuestion : mCurrentQuestion;
  }
  // this is a fail-safe method to cope with swiping
  private int nextQuestion() {
    return mCurrentQuestion < Quiz.size() - 1 ? ++mCurrentQuestion : mCurrentQuestion;
  }

  /**
   * Exception catcher for all questions as they are evaluated and displayed
   * @param question the question being evaluated
   */
  private void askQuestions(Question question) {
    if (question == null) return;
    try {
      displayQuestion(question);
    } catch (NoSuchMethodException e) {
      e.printStackTrace();
    } catch (IllegalAccessException e) {
      e.printStackTrace();
    } catch (InvocationTargetException e) {
      e.printStackTrace();
    } catch (InstantiationException e) {
      e.printStackTrace();
    }
  }

  /**
   * This is a convenience method for demo purposes
   * If you want to add new questions at compile time, this is where to do it
   * so they get added to the quiz when it first displays
   */
  private void createQuestions() {
    Question question = new TrueFalse("Trenton is the capital of New Jersey.");
    Quiz.add(question);
    question = new TrueFalse("New York City is the capital of New York State", false);
    Quiz.add(question);
    question = new ShortAnswer("What is the name of this app?");
    question.addChoice("Qwizzler");
    Quiz.add(question);
    question = new SelectOne("What is the capital of California?");
    question.addChoice("Las Angeles");
    question.addChoice("San Diego");
    question.addChoice("San Francisco");
    question.addChoice("Santa Cruz");
    question.addChoice("Santa Barbara");
    question.addChoice("Venice Beach");
    question.addChoice("Sacramento", true);
    Quiz.add(question);
    question = new SelectMany("Which months in the year have 30 days?");
    question.addChoice("January");
    question.addChoice("February");
    question.addChoice("March");
    question.addChoice("April", true);
    question.addChoice("May");
    question.addChoice("June", true);
    question.addChoice("July");
    question.addChoice("August");
    question.addChoice("September", true);
    question.addChoice("October");
    question.addChoice("November", true);
    question.addChoice("December");
    Quiz.add(question);
  }

  /**
   * converts a DP setting into the nearest pixel equivalent for the density of the device
   * @param desiredDP - the desired DP
   * @return - the pixel conversion from DP to pixels
   */
  private int getDP(int desiredDP) {
    return (int) (desiredDP * scale + 0.5f);
  }


  /**
   * Creates a new Layout, apply appropriate LayoutParams and orientation
   * @param question the question requesting a layout
   * @return a View Group of the type requested by the question
   */
  @NonNull
  private ViewGroup createParent(Question question) {
    // The parent View will always be some type of Linear Layout; set that as the default to avoid
    // potentially returning a null value
    ViewGroup viewGroup = new LinearLayout(this);
    try {
      Class<?> parentClass = question.getParentType();
      Constructor<?> cons = parentClass.getConstructor(Context.class);
      // create the new ViewGroup indicated by Reflection
      viewGroup = (ViewGroup)cons.newInstance(this);
      // set the layout parameters
      viewGroup.setLayoutParams(getMatchParentLayoutParams());
      // set the orientation
      ((LinearLayout)viewGroup).setOrientation(LinearLayout.VERTICAL);
    } catch (NoSuchMethodException e) {
      e.printStackTrace();
    } catch (InstantiationException e) {
      e.printStackTrace();
    } catch (IllegalAccessException e) {
      e.printStackTrace();
    } catch (InvocationTargetException e) {
      e.printStackTrace();
    }
    return viewGroup;
  }

  /**
   * Creates a new View of the type requested by the question
   * @param question the question requesting a visual control
   * @return a TextView object of the requested type
   */
  @NonNull
  private TextView createChild(Question question) {
    // create a non-null default value
    TextView textView = new TextView(this);
    try {
      Class<?> childClass = question.getControlType();
      Constructor<?> cons = childClass.getConstructor(Context.class);
      // create the control indicated by Reflection
      textView = (TextView)cons.newInstance(this);
    } catch (NoSuchMethodException e) {
      e.printStackTrace();
    } catch (IllegalAccessException e) {
      e.printStackTrace();
    } catch (InstantiationException e) {
      e.printStackTrace();
    } catch (InvocationTargetException e) {
      e.printStackTrace();
    }
    return textView;
  }


  /**
   * Creates all the visual elements required by the question and displays them
   * @param question - the question that needs to be displayed
   * @throws NoSuchMethodException - Reflection
   * @throws IllegalAccessException - Reflection
   * @throws InvocationTargetException - Reflection
   * @throws InstantiationException - Reflection
   */
  // Display the question and all of the answer choices on the screen
  private void displayQuestion(Question question)
      throws NoSuchMethodException,
      IllegalAccessException,
      InvocationTargetException,
      InstantiationException {
    // get the parent view group that we will add controls to
    ViewGroup viewGroup = createParent(question);
    // set any decorations on the TextView that displays the Question text
    setQuestionBox(question);

    // loop through all the choices for this question
    for (Question.Choice choice : question.getChoices()) {
      // create a control of the appropriate type; RadioButton, CheckBox and EditText are all TextView types
      TextView control = createChild(question);
      // set the text; for Short Answer questions, this will be the empty string
      if (control instanceof EditText) {
        // apply formatting and decorations to EditText
        control = setEditText(control, question);
      }
      else {
        // apply formatting and decoration to CheckBox / RadioButton
        control = setCompoundButton(control, question, choice);
      }
      // add control to the parent view group
      viewGroup.addView(control);
      // disable the control if question was already answered
      control.setEnabled(!question.isAnswered());
    }
    // remove any previous Views from the scroll view
    mScrollView.removeAllViews();
    // add newly composited viewGroup to the ScrollView
    mScrollView.addView(viewGroup);
    // move the scroll bar back to the top
    mScrollView.setScrollY(0);
  }

  /**
   * Accepts a base compound button and applies attributes based on the question state and choice
   * @param control the control to be decorated
   * @param question the question holding state about whether it was answered
   * @param choice the choice corresponding to the control and its historical state
   * @return a decorated control of the appropriate type
   */
  private TextView setCompoundButton(TextView control, Question question, Question.Choice choice) {
    // set the text of this Choice
    control.setText(choice.getText());
    // set the margins and padding for the control
    control.setLayoutParams(getMargins());
    control.setPadding(getDP(16), 0, 0, 0);
    // apply check mark if indicated
    ((CompoundButton)control).setChecked(choice.wasPreviouslyChosen());
    // decorate the control with a border box if required
    if (question.isAnswered()) {
      if (choice.wasPreviouslyChosen() && choice.isCorrect()) {
        control.setBackgroundResource(R.drawable.green_box);
      }
      else if (!choice.wasPreviouslyChosen() && choice.isCorrect()) {
        control.setBackgroundResource(R.drawable.green_box);
      }
      else if (choice.wasPreviouslyChosen() && !choice.isCorrect()) {
        control.setBackgroundResource(R.drawable.red_box);
      }
    }
    return control;
  }


  /**
   * Accepts a base EditText control and applied attributes based on the question state
   * @param control the control to be decorated
   * @param question the question holding state about whether it was answered
   * @return a decorated EditText control
   */
  private TextView setEditText(TextView control, Question question) {
    // set the hint to be shown in the background
    control.setHint("Type Answer Here");
    // decorate the control with a border box if required
    if (question.isAnswered()) {
      control.setText(((ShortAnswer)question).getProvidedAnswer());
      if (question.getAnsweredCorrectly()) {
        control.setBackgroundResource(R.drawable.green_box);
      } else {
        control.setBackgroundResource(R.drawable.red_box);
      }
    }
    return control;
  }

  /**
   * creates a LayoutParams object configured to Match Parent
   * @return a LayoutParams object configured to Match Parent
   */
  @NonNull
  private LinearLayout.LayoutParams getMatchParentLayoutParams() {
    return new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.MATCH_PARENT);
  }

  /**
   * creates a LayoutParams object
   * @return a LayoutParams object with width match_parent, height wrap_content and sets a 4dp top margin
   */
  @NonNull
  private LinearLayout.LayoutParams getMargins() {
    LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);
    layoutParams.setMargins(0, getDP(4), 0, 0);
    return layoutParams;
  }

  /**
   * Decorates the area where the question is displayed to indicate a previous correct or incorrect attempt
   * Set the text of the Question Box to the text of the question parameter
   * @param question the question to be displayed in the question box
   */
  private void setQuestionBox(Question question) {
    // shuffle the order of the choices so they appear in random order each time they are newly displayed
    if (!question.isAnswered()) { // question was not answered previously
      mQuestionText.setBackgroundResource(0); // clear the background
      Collections.shuffle(question.getChoices()); // shuffle the question order
    }
    else { // this question was already answered -- decorate the TextView
      if (question.getAnsweredCorrectly()) { // and it was answered correctly
        mQuestionText.setBackgroundResource(R.drawable.green_box);
      }
      else mQuestionText.setBackgroundResource(R.drawable.red_box);
    }
    // set the main question text
    mQuestionText.setText(question.getQuestionText());
  }

  /**
   * Captures onTouch events and sends them to the mDetector object for processing
   * @param event - type of event capture (e.g. tap, double tap, etc)
   * @return eventually, a boolean indicating the final disposition of the super method
   */
  @Override
  public boolean onTouchEvent(MotionEvent event){
    this.mDetector.onTouchEvent(event);
    return super.onTouchEvent(event);
  }

  /**
   * this is a simple inner class that only captures the onFling event since I don't care
   * about all of the other Touch events
   */
  class CustomGestureListener extends GestureDetector.SimpleOnGestureListener {

    @Override
    public boolean onFling(MotionEvent event1, MotionEvent event2, float velocityX, float velocityY) {
      // this was a left-to-right swipe
      if (event1.getX() < event2.getX() - 100) {
        // fire the previous button's onClick method
        previous_button.callOnClick();
      }
      // this was a right-to-left swipe
      else {
        // fire the next button's onClick method
        next_button.callOnClick();
      }
      return true;
    }
  }
}
